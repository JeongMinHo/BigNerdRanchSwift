# CHAPTER 1(시작하기)

```Swift
var str = "Hello Swift"
str += "!"
```

- String은 타입의 하나다. 타입은 데이터를 표현하는 특별한 구조입니다.
- str 변수는 'String 타입의 **인스턴스(instance)**  ' 이다.
- **함수(function)**는 구체적인 일을 하기 위해 컴퓨터에 명령을 보내는 일련의 코드 집합을 말한다.



# CHAPTER 2(타입, 상수, 변수)

- 변수와 상수는 데이터 타입을 가진다. 타입은 데이터의 본질을 설명하고, 데이터 처리 방식에 관한 정보를 컴파일러에 제공한다.
- 컴파일러는 이 타입을 근거로 하여 메모리를 얼만큼 준비해야 하는지 파악 할 수 있다.
- 또한, 변수에 엉뚱한 타입을 지정하지 않도록 타입 확인이라는 기능을 제공한다.
- **타입 어노테이션(type annotation)** 문법을 사용하여 타입을 명시적으로 선언하는 것이 가능하다.
- 변수는 값이 변할 수 있어 새로운 값을 대입하는 것이 가능하다. 하지만 값이 변하지 않는 인스턴스를 사용하기 위해서는 *상수(constant)* 를 사용하면 된다. 
- **문자열 삽입(String interpolation)** 기능을 이용하여 상수나 변수의 값을 새 문자열과 결합하는 것이 가능하다.



# CHAPTER 3(조건)

- if/else는 특정 논리 조건에 따라 코드를 실행한다. 비교적 간단한 '둘 중 하나' 인 상황에서 그 결과에 따라 코드가 실행된다. (둘 다 실행되지는 않는다.)

| 연산자 | 설명                                           |
| :----: | ---------------------------------------------- |
|   <    | 왼쪽의 수가 오른쪽의 수보다 작은지 판단        |
|   <=   | 왼쪽의 수가 오른쪽의 수보다 작거나 같은지 판단 |
|   >    | 오른쪽의 수가 왼쪽의 수보다 작은지 판단        |
|   >=   | 오른쪽의 수가 왼쪽의 수보다 크거나 같은지 판단 |
|   ==   | 왼쪽의 수와 오른쪽의 수가 같은지 판단          |
|   !=   | 왼쪽의 수와 오른쪽의 수가 다른지 판단          |
|  ===   | 두 인스턴스가 같은 참조를 가리키고 있는지 판단 |
|  !==   | 두 인스턴스가 같은 참조를 가리키지 않는지 판단 |

| 논리 연산자 | 설명                                                  |
| :---------: | ----------------------------------------------------- |
|     &&      | 논리곱(AND) : 두 조건이 모두 true일 때만 true다       |
|    \|\|     | 논리합(OR) : 두 조건 중 하나만 true여도 true다        |
|      !      | 논리 부정(NOT) : true는 false가, false는 true가 된다. |



- 삼항 연산자(Ternary Operator)

  - 삼항 연산자는 if/else와 매우 비슷하지만 문법이 더 간결하다.
  - a ? b : c 의 형태를 보인다. "a가 참이면 b를 하고 그렇지 않다면 c를 해라"

  ~~~swift
  message = population < 10000 ? "\(population) is a small town!" : "\(population) is pretty big!"
  ~~~



# CHAPTER 4(수)

- 정수(integer)는 소수점이나 소수부가 없는 수를 가리키며 whole number라고도 한다.
- 컴퓨터에서 사용하는 정수는 일정한 메모리 공간을 차지한다는 점에서 우리가 실생활에서 쓰는 정수랑은 다르다.
- macOS에서 Int는 64비트짜리 정수다. 따라서 표현할 수 있는 값이 모두 2^64개이다.
- iOS에서 Int는 더 복잡하다. 아이폰 5s, 아이패드 에어, 아이패드 미니 레티나 디스플레이부터 64비트를 채택했다. 그 이전의 기기들은 32비트 아키텍쳐이다.
- Int의 크기는 컴파일러가 프로그램을 빌드할 때 적절하게 결정한다.
- Swift에서는 크기를 분명하게 밝힌 정수 타입도 제공한다. 예를 들어 Int32는 32비트 부호 있는 정수 타입이다.



- 오버플로 연산자

~~~swift
let y: Int8 = 120
let z = y + 10
~~~

- 다음과 같은 코드를 작성하면 Xcode는 오류를 내게 된다.
- Execution was interrupted
  - y는 Int8 타입이므로 z의 타입을 Int8로 추론한다.
  - y에 10을 더하고 결과는 130이 된다.
  - 스위프트는 결과를 다시 z에 저장하기 전에 130이 Int8에 적합한 값인지 확인한다
- Int -128에서 127까지만 담을 수 있다. 따라서 함정에 빠져 더 이상 진행하지 못하고 프로그램을 중단한다.
- Swift는 값이 너무 크거나 작을 때 다르게 동작하는 **오버플로 연산자** 라는 것을 제공한다. 이 연산자들은 프로그램을 함정에 빠뜨리지 않고 '반대쪽으로 되돌린다.' 
- 오버플로 더하기 연산자는 &+ 이다.

~~~swift
let y: Int8 = 120
let z = y &+ 10
~~~

- 이렇게 작성한다면 -126이 저장된다.
- 왜냐하면 127이상이므로 반대쪽으로 되돌려, -128, -127, -126순으로 되돌아가기 때문이다.
- 다른 언어들의 경우 스위프트의 오버플로우 연산자가 제공하는 '반대쪽으로 되돌리기'를 기본을 채택하고 있지만 스위프트의 경우 프로그램의 중단을 감수하고서라도 오버플로나 언더플로를 막아 잠재적인 보안상 허점을 가지고 있는 것보다 낫다고 판단한 것이다.



- Swift에서 제공하는 부동소수점수 타입은 32비트 부동소수점수인 Float와 64비트 부동소수점수인 Double이다.
- Float와 Double의 비트 수가 다르다고 해서 표현할 수 있는 최댓값과 최솟값이 정수일 때처럼 달라지는 것은 아니다. 부동소수점수에서 비트 크기는 *수 자체의 정확성을 결정한다.*
- Double은 Float보다 정확성이 더 높다. 즉, 더 정확한 근삿값을 저장할 수 있다.

~~~swift
let d1 = 1.1
let d2: Double = 1.1
let f1: Float = 100.3

if d1 == d2 {
    print("d1 and d2 are the same!")
}

if d1 + 0.1 == 1.2 {
    print("d1 is 1.2!")
}
~~~

- 다음과 같은 코드가 있을때 d1 is 1.2! 는 출력되지 않는다. 
- 1.2를 포함하여 많은 수가 부동소수점으로는 정확하게 표현되지 않는다. 그 대신 컴퓨터는 1.2와 매우 가까운 값, 즉 최근삿값을 저장할 뿐이다. 1.1에 0.1을 더하면 1.20000000...1과 비슷한 값이 되고 스위프트는 출력될 때 반올림 되어 1.2가 된다. 하지만 엄밀하게는 서로 같지 않은 수이다. 따라서 if문을 통과하지 못한다.



# CHAPTER 5(switch)

- switch는 특정 값에 따라 경우의 수를 나눠 판단한다.
- 특정 값과 일치하는 경우에 해당 코드를 실행하는 것이다.
- default는 반드시 갖춰야 할 요소는 아니지만, switch의 모든 경우가 일일이 대조되었을 때는 마지막에 반드시 있어야 한다. 따라서 모든 값이 일일이 대조되도록 구체적인 경우를 제시하지 않고 default를 포괄적으로 제공하는 것이 효율적일 때가 많다.
- 대조 되려면 대조할 값의 타입과 대조되는 기준값의 타입이 일치되어야 한다.
- case에는 실행할 수 있는 코드 행이 적어도 하나는 존재해야 한다.
- **fallthrough 즉 제어권 전달문(control transer statement)** 는 어떤 방향으로 진행되던 실행 흐름을 바꾸는 것이 가능하다. 
- C나 Objective-C 등 다른 언어에서는 switch가 다르게 동작한다. 스위프트 이외의 언어에서 switch는 자동으로 다음 case의 코드를 실행한다. 따라서 이를 방지하기 위해서는 break라는 제어권 전달문을 각 case의 마지막 행에 두어야 한다. 스위프트의 경우 지정된 값과 일치하는 case가 실행되면 switch는 실행을 멈춘다.



- 값 바인딩(value binding)

  - 값 바인딩 기능을 적용하면 어떤 case에서 대조되는 기준값을 지역 상수나 변수에 묶을 수 있다.

  ~~~swift
  var statusCode: Int = 404
  
  switch statusCode {
  case 100, 101:
      errorString += "Informational, \(statusCode)"
  case 300...307:
      errorString += "Redirection, \(statusCode)"
  case 400...417:
      errorString += "Client error:, \(statusCode)"
  case let unknownCode:
      errorString = "\(unknownCode) is not a known error code"
  }
  
  let error = (code: statusCode, error: errorString)
  ~~~

  - 마지막 case에서 이전 case들에서 일치하지 않기 때문에 임시 변수인 unknownCode를 만들고, 이 임시 변수에 statusCode의 값을 바인딩했다.
  - unknownCode가 이전 case들과 일치하지 안흔 상태 코드를 받기 때문에 default를 명시적으로 둘 이유가 없어졌다.



- **튜플(tuple)** 은 논리적 연관성을 드러내어 한 군데에 저장할 때 유용한 방법이다.
- 튜플을 사용하면 서로 다른 값들이 하나의 복합 값으로 묶이며 묶어 놓은 결과는 순서 리스트의 구조를 보인다.



- switch vs if/else
  - switch는 주로 어떤 하나의 값을 여러 경우와 일일이 대조하며 비교할 때 유용하다. 반면 if/else는 하나의 조건을 판단할 때 어울린다.
  - switch는 구간과 대조하거나 값을 지역 상수 또는 변수에 바인딩하고, 튜플과 패턴을 대조할 수 있는 등 수많은 유용한 기능을 제공한다.



~~~swift
let age = 25

if case 18...35 = age {
  print("Cool")
}
~~~

- if case를 사용한다면 단순히 age가 지정 구간에 있는지 확인만 하고 default문을 작성할 필요도 없다. 
- 또한 switch에서와 마찬가지로 where를 사용하는 것도 가능하다.
- if-case는 조건이 하나뿐인 switch를 대치할 뿐만 아니라 switch의 패턴 대조 능력을 발휘한다. switch의 조건이 하나 뿐이고 default를 고려하지 않아도 된다면 if-case를 사용하는 것이 낫다.